= unical-3d-game =

=== Obbiettivo ===

L'obbiettivo è di creare uno sparatutto 3d in terza persona usando il linguaggio Java, l'API jMonkeyEngine e la sua estensione jME Physics per il supporto alla fisica (forze, velocità ecc).

=== Struttura ===

La struttura che abbiamo pensato di dare al gioco è in linea di massima a tre livelli:

  # Core
  # Grafica
  # Input

Il livello Core contiene tutta la logica di gioco: gestione punteggio e livello, gestione parametri di difficoltà etc

Il livello Grafica contiene tutte le classi grafiche che si occupano della visualizzazione in 3d del gioco.
Comunica con il livello Core tramite un'interfaccia (WorldInterface), che permette di mantenere questi due livelli sincronizzati.

Il livello Input contiene le classi relative all'interazione con l'utente, quindi l'InputHandler e tutte le azioni disponibili.
Comunica con la grafica di gioco in modo diretto.

=== Diagramma delle principali classi del gioco ===

http://unical-3d-game.googlecode.com/files/Game%20Classes.jpg

=== Difficoltà principali riscontrate ===

L'uso della fisica nel gioco ha comportato diverse complicazioni in quanto non esisteva una classe base delle librerie che supportasse a pieno sia la libreria grafica che la sua estensione fisica, perciò abbiamo scritto la classe PhysicsGame, estensione di AbstractGame, che riunisce in se sia la gestione della fisica offerta da jME Physics sia la gestione di tutti gli effetti grafici offerti da jME. 
Per la scrittura di questa classe abbiamo fatto riferimento alle classi base BaseSimpleGame di jME e SimpleBaseGame di jME Physics.

Un altro problema legato all'uso di queste librerie è l'impossibilità di gestire i movimenti dei personaggi e dei proiettili direttamente nella logica, in quanto si basano su calcoli interni alle librerie, le quali sono accedibili soltanto dal livello Grafica.
(Per esempio il movimento di un proiettile viene gestito completamente dalla fisica)

Abbiamo comunque cercato di massimizzare l'indipendenza della logica dalla grafica, arrivando al punto in cui per salvare lo stato attuale del gioco basta semplicemente salvarne la parte logica (pochi byte). 

=== Divisione Grafica / Logica ===

Abbiamo infine scelto di avere una rappresentazione doppia del mondo del gioco: un mondo logico (classe LogicWorld), e uno grafico (classe GraphicalWorld).

Ognuno dei due "mondi" contiene la relativa parte degli elementi base del gioco.<br>
es. LogicWorld conterrà tutti i personaggi logici mentre GraphicalWorld conterrà tutti i personaggi grafici.

Ogni elemento base del gioco è composto da due classi, una logica e una grafica.
es LogicCharacter contiene tutta la parte logica del personaggio, energia, munizioni, ecc mentre GraphicalCharacter ne contiene tutta la parte grafica, modello 3d ecc

Per identificare ogni elemento viene usato un campo stringa id.<br>
es. LogicPlayer LP1   -   GraphicalPlayer GP1
  LP1.id = player1   -   GP1.id = LP1.id = player1

Il mondo grafico viene inizializzato in base al contenuto del mondo logico (per questo motivo basta salvare soltanto la parte logica).
Mentre durante la fase di gioco il mondo logico verrà aggiornato dal mondo grafico.
Per esempio ad ogni update grafico viene aggiornata la posizione del player nel mondo logico tramite un metodo dell'interfaccia.

Similmente, quando viene rilevata la collisione di un proiettile con un personaggio, viene richiamato attraverso l'interfaccia, un metodo logico che scala l'energia del personaggio stesso ed eventualmente ne dichiara la morte.

Stesso procedimento per l'acquisizione di pacchetti energia e munizioni.

=== Gestione Punteggio e Livello di difficoltà automatico ===

Al giocatore viene assegnato un punteggio che aumenta o diminuisce durante il gioco, aumenta ad ogni uccisione di nemici e diminuisce quando è il giocatore a venir "ucciso"
A seconda del punteggio del giocatore, si passa da un livello all'altro. 
Il passaggio di livello comporta la modifica di alcuni parametri, come la vita del player e dei nemici, la capienza del caricatore del player e la precisione dei nemici. All'aumentare del livello i nemici diventano più difficili da eliminare in quanto hanno maggiore energia, inoltre aumenta la probabilità di essere colpiti dai loro proiettili in quanto aumenta la loro precisione.

=== Intelligenza nemici ===

L'ai dei nemici viene gestita attraverso degli stati.
Ogni stato ha due parametri, raggio di azione e raggio visivo:
il raggio di azione è la distanza minima del player dal nemico tale che questo passi all'attacco.
il raggio visivo è invece la distanza minima del player dal nemico tale che questo ne percepisca la presenza e vada quindi in allerta.

Normalmente i nemici sono in stato "Default", come sentinelle o piantoni, con uno scarso raggio visivo poichè non si aspettano di essere attaccati.

Se il giocatore entra nel raggio visivo di un nemico, questo passa in stato di attacco, e inzia sparare. Se a questo punto il giocatore scappa, il nemico passerà in uno stato di ricerca, ed inizierà a muoversi nell'ultima direzione in cui lo ha visto: in questo stato se ad un certo punto vede nuovamente il giocatore, torna in stato di attacco e spara, altrimenti, dopo aver coperto una certa distanza senza essere riuscito a scovare il giocatore, tornerà indietro alla sua posizione iniziale, restando per un certo tempo in stato di allerta.

Se il giocatore entra nel raggio di percezione di un nemico (più ampio del raggio visivo), questo passerà in stato di allerta e aumenterà il suo raggio visivo in quanto si aspetta un attacco. Dopo che il giocatore esce dal raggio di percezione del nemico, questo continua a restare in stato di allerta per un certo tempo, prima di tornare in stato default.

Inoltre se un nemico si accorge che un suo compagno è sotto attacco, passa in stato di attacco, aumentando il suo raggio visivo per riuscire a vedere il giocatore e sparare.

Diagramma di stato:

http://unical-3d-game.googlecode.com/files/enemy_statediagram.jpg

=== Menu di gioco ===

Il menu del gioco è stato implementato usando Swing. Questa scelta deriva più che altro dalla nostra volontà di studiare anche questo utile framework per java.
Vi è un menu principale, visualizzato all'avvio del gioco, da cui è possibile avviare una nuova partita, caricarne una salvata, personalizzare le opzioni del gioco o uscire.
Vi è inoltre un menu "inGame" che consente di salvare la partita attualmente in corso, ritornare ovviamente al gioco, oppure uscire.

=== Gestione input ===

La gestione dell'input nel gioco è affidata alla classe ThirdPersonInputHandler che estende InputHandler di jME e ad una seria di azioni (classi `*`Action che estendono InputAction).
Abbiamo sviluppato questa classe basandoci sull'omonima classe presente nella libreria jME, semplificandola e modificandola in base alle nostre esigenze.
In fine tutte le azioni (andare avanti indietro sparare ecc) non fanno altro che modificare delle variabili booleane, l'esecuzione effettiva dell'azione corrispondente ad un certo comando viene poi effettuata nella classe relativa in base al valore di tali variabili.<br>
es. la classe ForwardAction si occupa di impostare il valore della variabile movingForward del player.<br>
Il movimento vero e proprio verrà effettuato dalla classe GraphicalPlayer se la sua variabile movingForward ha valore true.
Questo sistema è stato ideato per la predisposizione alla modalità multiplayer:<br>
ad esempio se il player con id "player1" viene mosso, per far si che si muova anche negli altri computer, basta che l'echoserver mandi un messaggio a tutti (es. "player1 movingForward") in modo che questi impostino la relativa variabile booleana dell'oggetto con id "player1" a true.